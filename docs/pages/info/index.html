<!DOCTYPE html>
<html lang=en> <head><meta charset=utf-8><title>FakeTpl :: A fake template engine for different Shells</title><meta name=description content="A fake template engine for different Shells"><meta name=author content="Oleksii Tsvietnov"><meta name=keywords content="faketpl,bash template engine,shell template engine,template,template engine"><meta name=robots content=index,follow><meta name=viewport content="width=device-width, initial-scale=1.0"><!--[if lt IE 9]>
    <script src="http://faketpl.vorakl.name/theme/html5.js?v=1493837074"></script>
    <![endif]--><link rel=stylesheet href=http://faketpl.vorakl.name/theme/bootstrap-pygments.bundle.min.css?v=1493837074><link rel="shortcut icon" href=/favicon.ico?v=1493837074><meta name=apple-mobile-web-app-title content=FakeTpl><meta name=application-name content=FakeTpl></head> <body> <div class=navbar> <div class=navbar-inner> <div class=container> <a class=brand href=http://faketpl.vorakl.name/ >FakeTpl</a> <a class="btn btn-navbar" data-toggle=collapse data-target=.nav-collapse> <span class=icon-bar></span> <span class=icon-bar></span> <span class=icon-bar></span> </a> <div class=nav-collapse> <ul class="nav pull-right"> <!-- <li class="divider-vertical"></li> --> <li><a href=http://faketpl.vorakl.name/faketpl>download</a></li> <li><a href=https://github.com/vorakl/FakeTpl>repo</a></li> <li><a href=http://vorakl.name/ >blog</a></li> <li><a href=http://vorakl.name/pages/about/ >author</a></li> <!-- <li class="divider-vertical"></li> --> </ul> </div> </div> </div> </div> <div class=container> <div class=content> <div class=row> <div class=span12> <div class=article> <div class=content-title> <h1>A fake template engine for different Shells</h1> </div> <div><p><a class="reference external" href=https://travis-ci.org/vorakl/FakeTpl><img alt="Travis CI: continuous integration status" src=https://travis-ci.org/vorakl/FakeTpl.svg?branch=master></a></p> <ul class=simple> <li><a class="reference internal" href=#what-is-it>What is it?</a></li> <li><dl class="first docutils"> <dt><a class="reference internal" href=#how-to-get-started>How to get started?</a></dt> <dd><ul class="first last"> <li><a class="reference internal" href=#as-a-one-liner>...as a one-liner</a></li> <li><a class="reference internal" href=#as-an-included-script>...as an included script</a></li> <li><a class="reference internal" href=#intallation-into-a-docker-image-based-on-centos>Intallation into a docker image (based on CentOS)</a></li> <li><a class="reference internal" href=#intallation-into-a-docker-image-based-on-alpine>Intallation into a docker image (based on Alpine)</a></li> </ul> </dd> </dl> </li> <li><a class="reference internal" href=#examples>Examples</a></li> <li><a class="reference internal" href=#technical-details>Technical details</a></li> <li><a class="reference internal" href=#why-was-it-created>Why was it created?</a></li> <li><a class="reference internal" href=#are-there-any-other-similar-solutions>Are there any other similar solutions?</a></li> </ul> <div class=section id=what-is-it> <h2>What is it?</h2> <p>It's not a real template engine or a complete program. This is a working solution for a simple idea of using shell inlines as templates.</p> <p>Of course, it won't be convenient to use this sort of &quot;templates&quot; with files where are a lot of quotation marks or other expressions sensitive to the shell syntax, because it leads to escaping all these special characters. But, at the same time it is convenient for adding templates to any common configuration files and other similar cases, for which actually <tt class="docutils literal">faketpl</tt> was created.</p> <p>The solution is done as a little function which is called <tt class="docutils literal">faketpl</tt>. It's compatible with many sh-like shells because uses only basic instructions, which can be included in any script, either as a one-liner or an external script (after downloading from the Internet). Faketpl was tested in Bourne shell (sh), bash, zsh and ash (Busybox).</p> <p>Being so simple in terms of the idea and realization, it's, in most cases, much more powerful than real template engines! It allows to use most features of a shell interpreter as templates with the only limitation of writing them in one line. That means, there are conditions, loops, an output result of executing commands, content of files, etc and the only real dependency is a shell.</p> <p>To eliminate any security issues related to direct executing commands, this solution is meant to be used primarily in the isolated container's environment like Docker and especially for bootstrapping them.</p> </div> <div class=section id=how-to-get-started> <h2>How to get started?</h2> <p>Being compatible with many shells at the same time, faketpl cannot use one of them by default. But it's not a limitation. It's a freedom of a choice. Just &quot;include&quot; it into your script which is written in any sh-like language and start using as a function. There are two options: include as an one-liner or as a script from the Internet.</p> <div class=section id=as-a-one-liner> <h3>...as a one-liner</h3> <p>This is the simplest and the most reliable one. It doesn't require an internet connection but will be hard-coded once it's added. That defines a use case: when you need to integrate the fake template engine with some existing script/environment once and then use it without any requirements. So, just add this string in your shell code:</p> <div class=highlight><pre><span></span>faketpl<span class=o>()</span> <span class=o>{</span> <span class=nb>export</span> <span class=nv>IFS</span><span class=o>=</span><span class=s1>&#39;&#39;</span><span class=p>;</span> <span class=k>while</span> <span class=nb>read</span> -r _line<span class=p>;</span> <span class=k>do</span> <span class=nb>eval</span> <span class=nb>echo</span> <span class=se>\&quot;</span><span class=si>${</span><span class=nv>_line</span><span class=si>}</span><span class=se>\&quot;</span><span class=p>;</span> <span class=k>done</span><span class=p>;</span> <span class=o>}</span>
</pre></div> <p>Yep, that's only one line, really. Nothing more! :) Then, send a text with templates to stdin like here</p> <div class=highlight><pre><span></span><span class=o>(</span><span class=nb>echo</span> -e <span class=s1>&#39;Workers $(grep processor /proc/cpuinfo | wc -l)\nVirtualHost $(cat /proc/sys/kernel/hostname):${RANDOM}\nUsername ${SRV_NAME:-www}&#39;</span> <span class=p>|</span> faketpl<span class=o>)</span>
</pre></div> <p>If this command is run in a basic official docker container with Apline Linux with only Busybox on the board, then as a result, you'll see something like this</p> <div class=highlight><pre><span></span>Workers <span class=m>4</span>
VirtualHost 1a614d65b09c:10915
Username www
</pre></div> <p>That could be a part of some sort of dynamic config file of a web-server. Of course, more useful examples can be found below ;) And pay attention on using bounding parentheses! They are always needed. The explanation &quot;why?&quot; will be given a bit later.</p> </div> <div class=section id=as-an-included-script> <h3>...as an included script</h3> <p>The use case for this option is to use it in automated build environments, when you build an application from scratch. For example, while your pipeline builds a new docker image with some application, faketpl can be downloaded from the Internet by the instruction from a Dockerfile and then be invoked at run-time from the Entrypoint to transform templates to real configuration files, or html pages, or whatever else. As I've mentioned before, to support several backends (shells) at the same time, faketpl can be used only after &quot;sourcing&quot; it in the script and then being used as a function. So, let's download the script from the Github and check sha256 sum. You DON'T need to set an execution permission!</p> <p>For a Busybox backend, run as root</p> <div class=highlight><pre><span></span>wget -qO /usr/bin/faketpl http://faketpl.vorakl.name/faketpl <span class=o>&amp;&amp;</span> <span class=se>\</span>
<span class=o>(</span> <span class=nb>cd</span> /usr/bin <span class=o>&amp;&amp;</span> wget -qO - http://faketpl.vorakl.name/faketpl.sha256 <span class=p>|</span> sha256sum -c <span class=o>)</span>
</pre></div> <p>or using curl, run as root</p> <div class=highlight><pre><span></span>curl -sSLfo /usr/bin/faketpl http://faketpl.vorakl.name/faketpl <span class=o>&amp;&amp;</span> <span class=se>\</span>
<span class=o>(</span> <span class=nb>cd</span> /usr/bin <span class=o>&amp;&amp;</span> curl -sSLf http://faketpl.vorakl.name/faketpl.sha256 <span class=p>|</span> sha256sum -c <span class=o>)</span>
</pre></div> <p>Then, include it in the script by <tt class="docutils literal">source</tt> or <tt class="docutils literal">.</tt> command without specifying a full path (because it's already in the $PATH, in one of the standart directory for binaries)</p> <div class=highlight><pre><span></span><span class=nb>source</span> faketpl
</pre></div> <p>and then, set some values for variables from our &quot;template&quot; file. To render the file, just send it to the function and write an output to a real file:</p> <div class=highlight><pre><span></span><span class=nb>export</span> <span class=nv>MYNAME</span><span class=o>=</span>Oleksii
<span class=o>(</span>faketpl &lt; index.html.ftpl &gt; index.html<span class=o>)</span>
</pre></div> <p>If the <tt class="docutils literal">index.html.ftpl</tt> has this text:</p> <div class=highlight><pre><span></span><span class=cp>&lt;!DOCTYPE html&gt;</span>
<span class=p>&lt;</span><span class=nt>html</span><span class=p>&gt;</span>
    <span class=p>&lt;</span><span class=nt>body</span><span class=p>&gt;</span>
        <span class=p>&lt;</span><span class=nt>h1</span><span class=p>&gt;</span>Welcome to $(cat /proc/sys/kernel/hostname)<span class=p>&lt;/</span><span class=nt>h1</span><span class=p>&gt;</span>
        <span class=p>&lt;</span><span class=nt>div</span><span class=p>&gt;</span>My name is: <span class=p>&lt;</span><span class=nt>b</span><span class=p>&gt;</span>${MYNAME:-default}<span class=p>&lt;/</span><span class=nt>b</span><span class=p>&gt;&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
        <span class=p>&lt;</span><span class=nt>div</span><span class=p>&gt;</span>Random number: <span class=p>&lt;</span><span class=nt>b</span><span class=p>&gt;</span>${RANDOM}<span class=p>&lt;/</span><span class=nt>b</span><span class=p>&gt;&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
    <span class=p>&lt;/</span><span class=nt>body</span><span class=p>&gt;</span>
<span class=p>&lt;/</span><span class=nt>html</span><span class=p>&gt;</span>
</pre></div> <p>then, <tt class="docutils literal">index.html</tt> will have this result</p> <div class=highlight><pre><span></span><span class=cp>&lt;!DOCTYPE html&gt;</span>
<span class=p>&lt;</span><span class=nt>html</span><span class=p>&gt;</span>
    <span class=p>&lt;</span><span class=nt>body</span><span class=p>&gt;</span>
        <span class=p>&lt;</span><span class=nt>h1</span><span class=p>&gt;</span>Welcome to marche<span class=p>&lt;/</span><span class=nt>h1</span><span class=p>&gt;</span>
        <span class=p>&lt;</span><span class=nt>div</span><span class=p>&gt;</span>My name is: <span class=p>&lt;</span><span class=nt>b</span><span class=p>&gt;</span>Oleksii<span class=p>&lt;/</span><span class=nt>b</span><span class=p>&gt;&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
        <span class=p>&lt;</span><span class=nt>div</span><span class=p>&gt;</span>Random number: <span class=p>&lt;</span><span class=nt>b</span><span class=p>&gt;</span>20812<span class=p>&lt;/</span><span class=nt>b</span><span class=p>&gt;&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
    <span class=p>&lt;/</span><span class=nt>body</span><span class=p>&gt;</span>
<span class=p>&lt;/</span><span class=nt>html</span><span class=p>&gt;</span>
</pre></div> </div> <div class=section id=intallation-into-a-docker-image-based-on-centos> <h3>Intallation into a docker image (based on CentOS)</h3> <div class=highlight><pre><span></span>FROM centos:latest

RUN curl -sSLfo /usr/bin/faketpl http://faketpl.vorakl.name/faketpl <span class=o>&amp;&amp;</span> <span class=se>\</span>
    <span class=o>(</span> <span class=nb>cd</span> /usr/bin <span class=o>&amp;&amp;</span> curl -sSLf http://faketpl.vorakl.name/faketpl.sha256 <span class=p>|</span> sha256sum -c <span class=o>)</span>
</pre></div> </div> <div class=section id=intallation-into-a-docker-image-based-on-alpine> <h3>Intallation into a docker image (based on Alpine)</h3> <div class=highlight><pre><span></span>FROM alpine:latest

RUN wget -qP /usr/bin/  <span class=o>&amp;&amp;</span> http://faketpl.vorakl.name/faketpl
    <span class=o>(</span> <span class=nb>cd</span> /usr/bin <span class=o>&amp;&amp;</span> wget -qO - http://faketpl.vorakl.name/faketpl.sha256 <span class=p>|</span> sha256sum -c <span class=o>)</span>
</pre></div> </div> </div> <div class=section id=examples> <h2>Examples</h2> <p>I prepared <a class="reference external" href=https://github.com/vorakl/FakeTpl/tree/master/examples>a few examples</a> and suggest to start from <a class="reference external" href=https://github.com/vorakl/FakeTpl/tree/master/examples/one-liners>one-liners</a> to get more familiar with basic technics</p> </div> <div class=section id=technical-details> <h2>Technical details</h2> <p>Basically, it's as simple as go line by line trough the whole stream from stdin and print them out after the evaluation. That means if the shell can recognize some expressions they will be evaluated before printing out. To make this reading possible, the value of IFS variable is changed and this can screwed up you current running environment. That's why it's highly important to do all transformation in the sub-shell by putting the whole command in the parentheses. Another consequence is to use all desirable &quot;templates&quot; within one line. That's all. Only two requirement: to run inside <tt class="docutils literal">( )</tt> and to write all expressions in one line.</p> </div> <div class=section id=why-was-it-created> <h2>Why was it created?</h2> <p>I was looking for such kind solution for awhile and the reason is &quot;12 Factors&quot; of Cloud Native Applications with its 3rd statment <a class="reference external" href=https://12factor.net/config>Store config in the environment</a>. It basically says that an application has to be delivered with the configuration in most generic form, to make it's ready to be run in any specific environment without rebuilding or modifications of the base &quot;package&quot;. It has to be done by supplying a configuration for a particular instance (copy of an application) for a particular environment in terms of environment variables. For example, if some orchestration system runs a container with an application, it supplies all needed configuration as environment variables. In case of Docker, it would look like</p> <div class=highlight><pre><span></span>docker run -d -e <span class=nv>RUN_ENV</span><span class=o>=</span>dev -e <span class=nv>UPLOAD_HOST</span><span class=o>=</span><span class=m>1</span>.2.3.4 -e <span class=nv>MY_DOMAIN</span><span class=o>=</span>domain.com some-image-with-app
</pre></div> <p>That basically means that something inside the container has to modify the configuration of an application, at a boot time, to make it applicable for the current running environment. This can be achived easyly if the application is developed in-house and it supports such kind of behavior. For most popular programming languages there are available a lot of libraries with different template engines. But what if it doesn't support templates or there is a need to run 3rd party application on which we don't have any influence?</p> <p>Actually, this is the most common case when you need to run in the container in the Cloud some arbitrary application which is delivered as a unified image. If this application has a configuration stored in text files, then one of possible and convenient way to support 3rd statment of the &quot;12 Factors&quot; is to deliver the application with the most generic form of configuration using templates. Then, at run-time, just finalize configuration based on supplied environment variables by using some template engine.</p> <p>Of course, there are dozens of different template engines for many languages. It's not a big deal to install some scripting language, like Python, with template library and write a simple script. But! With containers the size matters ;) There is always a need to have a minimal image, without any unnecessary tools and the Shell is that reasonable minimum base which almost all containers have. Yes, there are templates engines in pure Bash but usually they support only simple traslation of variables (arrays) to their values, plus loops, but nothing more. So, you'll have to use some &quot;dialect&quot; of templates anyway. Honestly, this last option works pretty well. You can build a container image based on Alpine Linux with only Busybox inside, add one of a shell template engine and that's all. But suddenly, I came across a quite nice idea which opened a door to the full power of the shell that can be used as a sort of templates. Without any extra packages or additional syntax. Just pure shell one-liner in-lines and a simple function which tranlates them to values.</p> </div> <div class=section id=are-there-any-other-similar-solutions> <h2>Are there any other similar solutions?</h2> <p>Just a few examples...</p> <p>The idea, which made it possible to create faketpl, was found in <a class="reference external" href=https://github.com/alterway/docker-keepalived>alterway/docker-keepalived repo</a>. That was exactly what I needed and was looking for. At the same time I didn't like the implementation. In my opinion, it has a big drawback because it's limited by the size of files. But it wasn't a goal for the guys and their solution works pretty good for them. Their implementation puts the whole file in the command line before the evaluation and that's why it's limited and depends on the system. Anyway, it won't allow to deal with files bigger than <tt class="docutils literal">getconf ARG_MAX</tt> bytes. Although, I was needed a scalable solution.</p> <p>In the repo with <a class="reference external" href=https://github.com/nginxinc/docker-nginx>the official docker image of Nginx</a> maintainers added a similar functionality of configuring Nginx using simple variables as templates. For this purpose they use <tt class="docutils literal">envsubst</tt> tool from the <tt class="docutils literal">gettext</tt> package. It works fine but supports substituting only simple variables like ${var}. There is no possibility to set default values like ${var:-defult} or use other features of a shell.</p> <p>The Authors of <a class="reference external" href=http://www.haproxy.org/ >HAProxy</a> included the same feature directly in the application. There is an ability to use environment variables inside the configuration files without a need to run any external tools. That's really useful because you can inject them from the file before running the main process of HAProxy but it's limited only by using &quot;flat&quot; variables. There are no arrays, loops, etc. It's impossile, for instance, to build the whole config file with all backends from a little template. The example of how to do this using faketpl can be found below.</p> <!-- Links --> </div> </div> </div> </div> </div> </div> <footer> <p class=p-footer> <span class=pull-left> &copy; 2017 <a href=http://vorakl.name/pages/about/ >Oleksii Tsvietnov</a> All Rights Reserved </span> <span class=pull-right> Powered by <a href=https://github.com/getpelican/pelican>Pelican</a> and <a href=https://github.com/vorakl/aves>Aves</a> theme </span> </p> </footer> </div> <script src=http://faketpl.vorakl.name/theme/jquery-bootstrap-collapse.bundle.min.js?v=1493837074></script> </body> </html>